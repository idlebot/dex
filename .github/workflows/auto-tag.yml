# Runs on every push to main. Reads the commit title to decide how to bump the version.
# Commit titles should start with [major], [minor], or [patch]:
#   [patch] Fix download timeout   → v0.1.0 → v0.1.1
#   [minor] Add zip extraction     → v0.1.1 → v0.2.0
#   [major] Rewrite download engine → v0.2.0 → v1.0.0
# If no prefix is found, no tag is created.
name: Auto Tag

on:
  push:
    branches: [main]

permissions:
  contents: write   # Needed to push tags
  actions: write    # Needed to trigger the Release workflow via workflow_dispatch

jobs:
  auto-tag:
    name: Auto Tag
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history so we can find existing tags

      - name: Determine version bump
        id: bump
        run: |
          # Get the commit message of the push that triggered this workflow.
          COMMIT_MSG=$(git log -1 --pretty=%s)
          echo "Commit message: $COMMIT_MSG"

          # Check for [major], [minor], or [patch] prefix (case-insensitive).
          if echo "$COMMIT_MSG" | grep -iq '^\[major\]'; then
            echo "bump=major" >> $GITHUB_OUTPUT
          elif echo "$COMMIT_MSG" | grep -iq '^\[minor\]'; then
            echo "bump=minor" >> $GITHUB_OUTPUT
          elif echo "$COMMIT_MSG" | grep -iq '^\[patch\]'; then
            echo "bump=patch" >> $GITHUB_OUTPUT
          else
            echo "No version prefix found in commit message. Skipping."
            echo "bump=none" >> $GITHUB_OUTPUT
          fi

      - name: Calculate next version
        id: tag
        if: steps.bump.outputs.bump != 'none'
        run: |
          BUMP="${{ steps.bump.outputs.bump }}"

          # Find the latest version tag. `git tag -l 'v*'` lists all tags starting
          # with "v", then `sort -V` sorts them by version number, and `tail -1`
          # picks the highest. If no tags exist yet, default to v0.0.0.
          LATEST=$(git tag -l 'v*' | sort -V | tail -1)
          if [ -z "$LATEST" ]; then
            LATEST="v0.0.0"
          fi

          echo "Latest tag: $LATEST"

          # Strip the "v" prefix and split into major.minor.patch components.
          VERSION="${LATEST#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Increment the appropriate component based on the commit prefix.
          # Semantic versioning rules:
          #   major bump → reset minor and patch to 0
          #   minor bump → reset patch to 0
          #   patch bump → just increment patch
          case "$BUMP" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          NEW_TAG="v${NEW_VERSION}"
          echo "New tag: $NEW_TAG"
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update Cargo.toml version, commit, and tag
        if: steps.bump.outputs.bump != 'none'
        run: |
          NEW_VERSION="${{ steps.tag.outputs.version }}"
          NEW_TAG="${{ steps.tag.outputs.tag }}"

          # Update the version field in Cargo.toml using sed.
          # This matches the line `version = "x.y.z"` under [package] and replaces
          # just the version string. The pattern is specific enough to avoid matching
          # dependency version lines.
          sed -i "0,/^version = \".*\"/s//version = \"$NEW_VERSION\"/" Cargo.toml

          # Regenerate Cargo.lock to reflect the new version.
          cargo update --workspace

          # Commit the version bump. This commit message intentionally has no
          # [major]/[minor]/[patch] prefix, so the next auto-tag run (triggered
          # by this push) will be a harmless no-op.
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Cargo.toml Cargo.lock
          git commit -m "Bump version to $NEW_VERSION"

          # Tag this new commit (which has the correct version in Cargo.toml)
          # so the release build picks up the right version.
          git tag "$NEW_TAG"

          # Push both the commit and the tag together.
          git push origin main "$NEW_TAG"

      - name: Trigger release workflow
        if: steps.bump.outputs.bump != 'none'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh workflow run release.yml --ref main --field tag=${{ steps.tag.outputs.tag }}
